## 笔记
- 如果一个对象不可达，则会被垃圾回收机制回收
- 判断是个对象是否可达，可以看从跟出发是否能找到该对象
### 常见GC算法
- 引用计数
- 标记清除
- 标记整理
- 分代回收

### 引用计数算法
- 核心思想：设置引用数，判断当前引用数是否为0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为0时立即回收

#### 优点：
- 可以及时回收垃圾对象
- 减少程序卡顿时间

#### 缺点：
- 无法回收循环引用的对象
- 资源消耗较大（需要实时维护程序计数器）

### 标记清除算法
- 核心思想：分标记和清除两个阶段完成
- 遍历所有对象，标记活动对象
- 遍历所有对象，清除没有标记的对象
- 回收相应空间

#### 相比引用计数法的优势
- 可以回收循环引用对象

#### 存在的问题
- 会产生碎片化空间，不利于空间使用
- 不会立即回收垃圾对象

### 标记整理算法
- 标记整理可以看做是标记清除的增强
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理，移动对象位置

#### 相比标记清除
- 减少碎片化空间
- 同样不会立即回收垃圾对象

### V8垃圾回收
- V8有设置内存上限
- 采用分代回收的思想
- 内存分为新生代和老生代
- 针对不同对象采用不同的算法

#### V8中常用GC算法
- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

#### V8如何回收新生代对象
- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为二个等大小空间
- 使用空间为From，空闲空间为To
- 活动对象存储于From空间
- 标记整理后将活动对象拷贝至To
- From与To交换完成释放

#### 回收细节说明
- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动至老生代
- 一轮GC还存活的新生代需要晋升
- To空间的使用率超过25%

#### V8如何回收老生代对象
- 主要采用标记清除、标记整理、增量标记
- 首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化（当新生代晋升而老生代空间不足时）
- 采用增量标记进行效率优化

#### 细节对比
- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不适合用复制算法（1.空间浪费，2.对象多，复制耗时）

#### 增量标记
- 垃圾回收的时候会阻塞程序执行
- 增量标记将原先遍历对象标记的操作分为了多步去执行
- 程序执行和标记交替执行

### Performance
#### 内存问题的外在表现
- 页面出现延迟加载或者经常性暂停
- 页面持续性出现糟糕的性能
- 页面的性能随着时间延长越来越差（内存泄漏）

#### 界定内存问题的标准
- 内存泄漏：内存使用持续升高（只有上升，没有下降）
- 内存膨胀：在多数设备上都存在性能问题（排除设备性能不佳的影响）
- 频繁垃圾回收：通过内存变化图进行分析

#### 监控内存的几种方式
- 浏览器任务管理器
- Timeline时序图记录
- 对快照查找分离DOM
- 判断是否存在频繁的垃圾回收

#### 任务管理器监控内存
- 快捷键：`shift` + `esc`
- 调出JavaScript内存列
- 内存列主要表示dom结点的内存使用情况
- JavaScript列表示堆内存使用情况，小括号表示可达对象的情况

#### Timeline记录内存变化
- 步骤：开启录制，操作，结束录制
- 关注内存变化曲线，有多条曲线，可以只勾选展示某种类型的曲线，比如JS堆曲线
- 有涨有降说明正常，直线上升说明可能有内存泄漏

#### 堆快照查找分离DOM
##### 什么是分离DOM
- 界面元素存活在DOM树上
- DOM节点不在DOM树上，且没有被js代码引用时，就是垃圾，会被回收
- 分离状态的DOM节点：不在DOM树上，但是被js代码引用了，此时会占据内存空间，造成内存泄漏

##### 如何监控
- 堆快照记录某个时刻JS堆情况
- 打开控制台的`内存`面板
- 选择堆快照选项，点击获取快照
- 搜索detached关键字，可以看到是否有分离dom

#### 判断是否存在频繁GC
##### 为什么确定频繁垃圾回收？
- GC工作时应用程序是停止的
- 频繁且过长的GC会导致应用假死
- 用户使用中感知应用卡顿，体验不好

##### 如何判断？
- Timeline中频繁的上升下降（时间间隔短）
- 任务管理器中数据频繁的增加减小


### 代码优化
#### 如何精准测试JavaScript性能
- 本质上就是采集大量的执行样板进行数学统计和分析
- 使用基于Benchmark.js的 https://jsperf.com/ 来完成

#### Jsperf使用流程
- 使用GitHub账号登录
- 填写个人信息（非必须）
- 填写消息的测试用例信息（title、slug）
- 填写准备代码（DOM操作时经常使用）
- 填写必要的setup与teardown代码
- 填写测试代码片段

#### 慎用全局变量
- 全局变量定义在全局执行上下文，是所有作用域链的顶端，因此查找路径长
- 全局执行上下文一直存在于上下文执行栈中，直到程序退出
- 如果某个局部作用域出现了同名变量则会产生遮蔽或污染全局
- 测试用例：拼接大字符串，一个使用全局变量的，一个不使用全局变量
- 提升较大

#### 缓存全局变量
- 将使用中无法避免的全局变量缓存到局部
- 有小幅提升
- 测试用例：查找dom结点，一个缓存document到局部变量，一个不缓存

#### 通过原型新增方法
- 在原型对象上新增实例对象需要的方法
- 提升14%
- 测试用例：一个把函数挂到实例对象上，一个挂到原型对象上

#### 避开闭包陷阱
- 闭包使用不当很容易出现内存泄漏
- 不要为了闭包而闭包
- 测试用例：定义一个方法用于执行传入的函数，传入时一种是传入一个已定义的函数，一种是传入未定义的函数
- 提升很小

#### 避免属性访问方法使用
- 测试用例：一个用get方法访问属性，一个直接访问属性
- 提升28%

#### for循环优化
- 测试用例：一个从0开始遍历，一个从数组结尾开始遍历，区别在于访问数组length的次数
- 提升很小

#### 采用最优循环方式
- 测试用例：forEach遍历，for遍历，forin遍历
- 性能对比：forEach > for > forin，forEach明显优于其他两个

#### 文档碎片优化节点添加
- 节点的添加操作必然会有回流和重绘
- 测试用例：一个直接循环添加节点，一个使用文档碎片
- 提升有限

#### 克隆优化节点操作
- 测试用例：一个是重新创建dom节点插入到文档，一个是克隆已有的dom节点，修改后插入文档
- 提升很小

#### 通过直接量替换new对象操作
- 测试用例：一个使用new Array()，一个用[]
- 提升很小

## 疑问
1. 新生代也要标记整理吗？
2. 为什么可以进行增量标记，如何工作的？
3. 传递未预先定义函数也算闭包？是说函数可能访问外部变量吗？
4. 

## 练习
1. 创建大数组，并用任务管理器监控内存使用
2. 创建大量结点，创建大字符串，用timeline监控
3. 新建dom节点，只引用，不插入文档，用堆快照监控
4. 使用jsperf测试代码性能
